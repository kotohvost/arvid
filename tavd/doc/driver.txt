
		Описание драйвера арвида под UNIX FreeBSD-2.x

===========================================================================
				ПРИМЕЧАНИЕ
Описание драйвера не стоит рассматривать как ПОЛНОЕ. Не стоит также уделять
большое внимание на некоторые неточности при описании, например входных
параметров для програм, так как это привело бы к запутыванию читателя :)
Сам драйвер естественно написан с учетом всех пожеланий кернела системы.
===========================================================================

	Драйвер состоит из следующищ основных частей:

1. Тест наличия платы и ее тестирование.
2. Инициализация драйвера.
3. Открытие драйвера.
4. IOCTL - управление драйвером.
5. Чтение данных.
6. Запись данных.
7. Закрытие драйвера.
8. Программа обработки прерываний.

		1. Тест наличия платы и ее тестирование.
	avtprobe() - это первая функция вызываемая кернелом юникса,
которая при успешном завершении возвращает количество используемых
ресурсов (портов). В качестве входных параметров ей передается номер девайса
который должен использовать драйвер при работе и параметрами для этого девайса.

PS.(на самом деле передается указатель на структуру в которой содержатся адреса
портов, номер прерывания, номер канала ДМА и другие параметры)

	Сама функция содержит вызовы других функций определяющих наличие и тип
контроллера, а также тестирующие контроллер на предмет правильной работы. При
сбое функции возвращают код ошибки = 1. Эти функции также устанавливают
переменные в структуде драйвера для дальнейшей правильной работы драйвера.
Это:
	а. avtcheck - тест и определение типа контроллера
	б. avttest - тестирование контроллера.
	avtcheck() - содержит код определения контроллеров 1020, 1030, 1031,
1051 и 1052. Контроллеры 1010 пока не поддерживаются.
	avttest() -  содержит код тестирующий режим работы ДМА для 1020 или
тест памяти для 1030, 1031, 1051 и 1052.
	Если avtprobe() завершится неудачно, дальнейшая работа с драйвером
блокируется операционной системой.

		2. Инициализация драйвера.
	avtattach() - эта функция вызывается после успешного выполнения
avtprobe(). Она инициализирует структуру для работы дайвера с данной картой,
и программу обработчик прерываний от данной карты.
	Для карт 1020 регистрируется ДМА канал и область памяти. Основная
проблемма с ДМА это его ограничение на ISA в размере 16мег, которое во FreeBSD
как бы решено через дополнительный буфер. Однако у меня нет пока возможности
это проверить. Так как у меня всего 16Мег :) Однако проверил - работает :)

		3. Открытие драйвера.
	avtopen() - эта функция вызывается операционной системой при выполнении
конструкции "fd = open(DEVICE, MODE, PERMISSION);". Функция резервирует
программный кольцевой буфер в памяти для функций чтения/записи, устанавливает
режим работы карты в 'READ DATA FROM VCR', разрешает прерывания от карты, или
инициализирует их в случае 1010 и 1020, а также разрешает обмен ДМА для 1020.
	Следует отметить, что при разрешении прерываний работа с картой
впринципе не ведется. Так как загрузка системы при чтении/записи по шине в
моем контупере (OverDrive DX4/100) занимает 14% по systat. Так что при открытии
драйвера загрузки системы ненаблюдается.

		4. IOCTL - управление драйвером.
	avtioctl() - данная функция позволяет управлять работой драйвера
после его открытия функцией open(). С ее помощью можно устанавливать режим
'чтения/записи' и 'данные/команды ВМ', и получать информацию о установках
драйвера и его состоянии.
	После установки любого режима кроме 'VNONE' драйвер сразу начинает
обмен данными с картой.

		5. Чтение данных.
	avtstrategy() -> avtread() - данная функция позволяет считывать
информацию из кольцевого буфера драйвера, если есть заполненые буфера.
Конструкция "long read(fd, *tobuffer, sizeinbyte);"

		6. Запись данных.
	avtstrategy() -> avtwrite() - эта функция позволяет записывать
информацию в кольцевой буфер драйвера, если есть свободные буфера.
Конструкция "long write(fd, *frombuffer, sizeinbyte);"

		7. Закрытие драйвера.
	avtclose() - данная функция завершает работу с драйвером. Она
ожидает завершения работы с колцевым буфером при записи, ждет их освобождения,
запрещает обмен с ДМА для 1020, запрещает прерывание от карты и освобождает
кольцевой буфер.

		8. Программа обработки прерываний.
	avtintr() - это основная функция драйвера, работающая напрямую с картой
Арвида и с кольцевым буфером. Функция работает в режиме: пришло прерывание -
надо его обработать. В зависимости от режима работы 'READ/WRITE' выполняются
программы чтения/записи из/в карту Арвида. Для карт:
	1010 вызывается отдельная программа работы с картой 1010
	1020 вызывается отдельная программа работы с картой 1020
	1030, 1031, 1051, 1052 вызывается одна универсальная программа.
	При чтении данные из карты Арвида переносятся в кольцевой буфер. Если
в колцевом буфере нет свободного места, данные из карты не читаются. Если в
карте Арвида нет буферов для чтения прерывание заканчивается.
	При записи данные из кольцевого буфера переносятся в карту Арвида. Если
данных нет прерывание заканчивается. Если в карте Арвида нету свободных буферов
для записи прерывание заканчивается.
	Обмен данными с картой производиться блоками с размером зависящим от
текущего режима плотности (100/200/325). За одно прерывание возможно чтение
или запись до четырех (4) блоков. Это обусловленно тем явление, что при выдаче
команды управления видеомагнитофоном, есть возможность пропуска кадра, что
неприемлемо для такого режима.
