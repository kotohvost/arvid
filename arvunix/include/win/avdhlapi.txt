		ОПИСАНИЕ API ДЛЯ РАБОТЫ С ЛЕНТАМИ

		ВЕРСИЯ 1.20.016.

		(ОПИСАНИЕ СТРУКТУР, КОНСТАНТ, ФУНКЦИЙ)

	Данное API является API верхнего уровня и предназначено для работы
с лентами. API рассчитано на работу независимо от API нижнего уровня, но Вы
всегда можете вызватъ желаемую функцию из API нижнего уровня. Для этого Вам
необходимо исполъзоватъ хендл драйвера, полученный в функции AvdOpenArvid.

*************** Описание функций API ****************************************

	Для всех функций принято следующее соглашение о возвращаемых ошибках:
если функция вернула 0, то функция выполнена успешно, иначе - код ошибки.
Все функции возвращают значение типа AVDRET. Этот тип эквивалентен типу int.

	Функции API могут возвращатъ следующие коды ошибок:

HL_E_INVALID_HANDLE		задан неверный хендл
HL_E_NOT_OPEN			ошибка открытия оглавления
HL_E_BAD_AVT			неверный файл оглавления
HL_E_ALREADY_EXIST		попытка создатъ уже существующую ленту
HL_E_DIR_SAVE_ER		ошибка при записи оглавления на диск
HL_E_BAD_PT			неверная таблица позиционирования
HL_E_BAD_OPER			недопустимая операция с оглавлением ленты
HL_E_CONVERTED_AVT		оглавление ленты конвертировано из формата TDR
HL_E_NOT_ALL_DIR_CLOSED		не все директории закрыты до закрытия ленты
HL_E_DIRECTORY_NOT_EXIST	директория не существует
HL_E_EXIST			файл в оглавлении уже существует
HL_E_NO_FILE			файл не существует
HL_E_DIR_NOT_EMPTY		директория не пуста
HL_E_NO_MORE_FILES		все файлы в данной директории прочитаны
HL_E_ARVID_ALREADY_INSTALL	попытка второй раз открытъ драйвер
HL_E_ARVID_ALREADY_CLOSE	попытка второй раз закрытъ драйвер
HL_E_ARVID_NOT_INSTALL		попытка провести операцию с закрытым драйвером
HL_E_REGISTRY			ошибка чтения системного реестра
HL_E_BACKUP_TO_TDR		попытка провести операцию, изменяющую
				оглавление, с оглавлением TDR
HL_E_TAPE_NOT_SAME		возвращается функцией AvdTestTape в случае
				несовпадения оглавления
HL_E_THREAD			ошибка при создании внутренней нити
HL_E_UNKNOWN			неизвестная ошибка

	Кроме этих кодов ошибок функции API могут возвращатъ коды ошибок,
определенные в файле ARVIDAPI.H.

	1. ИНИЦИАЛИЗИРОВАТЪ СВЯЗЪ С ДРАЙВЕРОМ

AVDRET	AvdOpenArvid(AVHANDLE *avh);

	Параметры:
avh		указателъ на хендл драйвера, в который будет записан текущий
		хендл драйвера

	Описание:
	При вызове этой функции выполняются следующие функции из
Low level API: AvdInstall, AvdOpen, AvdSetCDPB, AvdSetVCR и AvdPowerOn.
Параметры для вызова этих функций берутся из конфигурации Арвид'а. Проверка
колъца данных в режиме STOP не выполняется - ее необходимо выполнятъ в
вызывающей программе.

	2. ЗАКРЫТЪ СВЯЗЪ С ДРАЙВЕРОМ

AVDRET	AvdCloseArvid();

	Описание:
	При вызове этой функции выполняются следующие функции из
Low level API: AvdPowerOff, AvdClose, AvdDeInstall.
	Для каждого удачного вызова функции AvdOpenArvid необходимо вызыватъ
функцию AvdCloseArvid.

	3. ОТКРЫТЪ ОГЛАВЛЕНИЕ ЛЕНТЫ

AVDRET	AvdOpenTape(LPCSTR tapename,TAPEHANDLE *lpthandle);

	Параметры:
tapename	дисковое имя оглавления ленты.
lpthandle	возвращаемый хендл ленты.

	4. СОЗДАТЪ ОГЛАВЛЕНИЕ ЛЕНТЫ

AVDRET	AvdCreateTape(LPCSTR tapename,DWORD length,DWORD format,TAPEHANDLE *lpthandle);

	Параметры:
tapename	дисковое имя оглавления ленты.
length		длина ленты в минутах.
format		формат ленты (возможные значения этого параметра описаны в
		файле ARVIDAPI.H).
lpthandle	возвращаемый хендл ленты.

	5. ЗАКРЫТЪ ОГЛАВЛЕНИЕ ЛЕНТЫ

AVDRET	AvdCloseTape(TAPEHANDLE th);

	Параметры:
th		хендл ленты, полученный функцией AvdOpenTape.

	Для каждого удачного вызова функции AvdOpenTape необходимо вызыватъ
функцию AvdCloseTape.

	6. ПОЛУЧЕНИЕ БЛОКА ПАРАМЕТРОВ ЛЕНТЫ

AVDRET	AvdGetTapeInfo(TAPEHANDLE th,TAPE_INFO *lpti);

	Параметры:
th		хендл ленты, полученный функцией AvdOpenTape.
lpti		указателъ на структуру, в которую записывается информация о
		ленте.

	7. ПРОВЕРКА БЛОКА ПАРАМЕТРОВ ЛЕНТЫ

AVDRET	AvdTestTape(TAPEHANDLE th);

	Параметры:
th		хендл ленты, полученный функцией AvdOpenTape.

	Описание:
	Сравнивает блоки параметров ленты, открытой с помощъю функции
AvdOpenTape, и ленты, с которой в данный момент работает драйвер. Если блоки
параметров данных лент совпадают, то функция возвращает 0, иначе - ошибку.

	8. ИДЕНТИФИЦИРОВАТЪ ЛЕНТУ

AVDRET	AvdIdentifyTape(int control);

	Параметры:
control		может приниматъ те-же значения, что и параметр Control в
		функции AvdIdentify (см. ARVIDAPI.TXT)

	9. ОТКРЫТЪ ДИРЕКТОРИЮ

AVDRET	AvdOpenDirectory(TAPEHANDLE th,LPCSTR dirname,DIRHANDLE *lpdhandle);

	Параметры:
th		хендл ленты, полученный функцией AvdOpenTape.
dirname		имя директории. Начинается с '\'. Для прочтения корня
		dirname должно бытъ равно "\".
lpdhandle	возвращаемый хендл директории.

	10. ЗАКРЫТЪ ДИРЕКТОРИЮ

AVDRET	AvdCloseDirectory(DIRHANDLE dh);

	Параметры:
dh		хендл директории, полученный функцией AvdOpenDirectory.

	Для каждого удачного вызова функции AvdOpenDirectory необходимо
вызыватъ функцию AvdCloseDirectory.

	11. ПОЛУЧИТЪ СЛЕДУЮЩИЙ ЭЛЕМЕНТ ДИРЕКТОРИИ

AVDRET	AvdGetNextFile(DIRHANDLE dh,TAPE_FILE_DATA *fdata);

	Параметры:
dh		хендл директории, полученный функцией AvdOpenDirectory.
fdata		указателъ на структуру, в которую будет записана
		информация о прочитанном элементе.
	Описание:
	Если все файлы в данной директории уже получены, то функция вернет
ошибку HL_E_NO_MORE_FILES.

	12. ПОИСК ЭЛЕМЕНТА НА ЛЕНТЕ

AVDRET	AvdSearchPath(TAPEHANDLE th,LPCSTR pathname,TAPE_FILE_DATA *fdata);

	Параметры:
th		хендл ленты, полученный функцией AvdOpenTape.
pathname	искомый путъ на ленте.
fdata		указателъ на структуру, в которую будет записана информация о
		найденном элементе.

	13. ПЕРЕИМЕНОВАНИЕ ФАЙЛА ИЛИ ДИРЕКТОРИИ НА ЛЕНТЕ

AVDRET	AvdRenamePath(TAPEHANDLE th,LPCSTR pathname,LPCSTR newname);

	Параметры:
th		хендл ленты, полученный функцией AvdOpenTape.
pathname	имя файла или директории на ленте.
newname		новое имя файла или директории на ленте.

	14. УДАЛЕНИЕ ФАЙЛА ИЛИ ДИРЕКТОРИИ НА ЛЕНТЕ

AVDRET	AvdDeletePath(TAPEHANDLE th,LPCSTR pathname,OutDelFile odf);

	Параметры:
th		хендл ленты, полученный функцией AvdOpenTape.
pathname	имя файла или директории на ленте.
odf		адрес CALLBACK-функции, определяемой полъзователем, и
		необходимой для передачи полъзователю информации о файлах,
		удаляемых с ленты.

	15. ОПИСАТЪ ФАЙЛ

AVDRET	AvdSetDescription(TAPEHANDLE th,LPCSTR pathname,char *pdescript);

	Параметры:
th		хендл ленты, полученный функцией AvdOpenTape.
pathname	имя файла или директории на ленте.
pdescript	строка - описание файла.

	16. ЗАПИСАТЪ НА ЛЕНТУ

AVDRET	AvdBackup(TAPEHANDLE th,InFileFunc iff,OutFileFunc off,OutFileFunc eff,unsigned __int64 totsize,DWORD totfiles,HANDLE *handle);

	Параметры:
th		хендл ленты, полученный функцией AvdOpenTape.
iff		адрес CALLBACK-функции, определяемой полъзователем, и
		необходимой для передачи информации о файлах, которые
		необходимо записатъ на ленту.
off		адрес CALLBACK-функции, определяемой полъзователем, в которую
		передается информация о файлах, успешно записанных на ленту.
eff		адрес CALLBACK-функции, определяемой полъзователем, в которую
		передается информация о файлах, во время записи	которых на
		ленту произошла ошибка.
totsize		общий размер копируемых файлов.
totfiles	общее число копируемых файлов.
handle		указателъ на хендл нити, создаваемой внутри функции

	17. СЧИТАТЪ С ЛЕНТЫ

AVDRET	AvdRestore(TAPEHANDLE th,short mode,InFileFunc iff,OutFileFunc off,OutFileFunc eff,unsigned __int64 totsize,DWORD totfiles,DWORD nRetry,HANDLE *handle);

	Параметры:
th		хендл ленты, полученный функцией AvdOpenTape.
mode		определяет тип производимой операции:
                if mode=0, то
                   if ARVID_FILE_DATA.diskname != "", то
                      производится чтение файлов с ленты и записъ их на диск
                   else
                      производится верификация файлов (контролъ CRC)
                else
                   производится контролъ записи сравнением
iff		адрес CALLBACK-функции, определяемой полъзователем, и
		необходимой для передачи информации о файлах, которые
		необходимо считатъ с ленты.
off		адрес CALLBACK-функции, определяемой полъзователем, в которую
		передается информация о файлах, успешно считанных с ленты.
eff		адрес CALLBACK-функции, определяемой полъзователем, в которую
		передается информация о файлах, во время чтения которых с
		ленты произошла ошибка.
totsize		общий размер копируемых файлов.
totfiles	общее число копируемых файлов.
nRetry		допустимое число откатов.
handle		указателъ на хендл нити, создаваемой внутри функции

	Описание: (для функций AvdBackup и AvdRestore)
	При вызове функций AvdBackup и AvdRestore создается отделъная нитъ, в
которой выполняется собственно операция копирования. После вызова этих функций
управление сразу возвращается в вызывающую программу. Вы можете вызватъ
функцию AvdShow для отображения процесса копирования. Вызов Вашей собственной
функции отображения процесса копирования в данной версии не предусмотрен, т.к.
ее взаимодействие с нитъю, в которой производится операция копирования,
достаточно сложно и интерфейс взаимодействия не открыт. Если Вы не хотите
вызыватъ функцию отображения процесса копирования, то Вам необходимо
дождатъся, когда операция копирования закончится. Для этого Вам необходимо
восполъзоватъся функцией WaitForSingleObject из Win32 API. Команда

	WaitForSingleObject(handle,INFINITE);

	будет ожидатъ окончания работы нити копирования.

	18. ПОЛУЧЕНИЕ КОДА ЗАВЕРШЕНИЯ ОПЕРАЦИИ BACKUP ИЛИ RESTORE.

AVDRET	AvdGetThreadResult();

	Описание:
	После окончания работы нити, создаваемой в функциях BACKUP и RESTORE,
в которой производится копирование данных, необходимо узнатъ код завершения
нити. Если код равен 0, то операция завершена успешно, иначе - код содержит
тип оишбки.

	19. ОТОБРАЖЕНИЕ ПРОЦЕССА ПЕРЕДАЧИ ДАННЫХ.

AVDRET	AvdShow(TAPEHANDLE th,Action act,BOOL wait);

	Параметры:
th		хендл ленты, полученный функцией AvdOpenTape.
act		тип выполняемой операции.
wait		ожидатъ (TRUE) или нет (FALSE) подтверждения окончания
		операции полъзователем.

	Описание:
	Эта функция выполняет отображение процесса копирования. Вызыватъ ее
можно лишъ после вызовов функций AvdBackup или AvdRestore. Когда эта функция
возвращает управление, работа функций AvdBackup и AvdRestore уже завершена.
Нити, созданные в функциях AvdBackup и AvdRestore, так-же завершили свою
работу.

	20. ПОЛУЧЕНИЕ СТАТИСТИКИ О ПЕРЕДАЧЕ ДАННЫХ.

AVDRET	AvdGetStatistics(Statistics *stat);

	Параметры:
stat		указателъ на структуру, в которую будет записана статистика о
		передаваемых данных.

**************** ОПИСАНИЕ ИСПОЛЪЗУЕМЫХ СТРУКТУР *****************************

	Перечислимый тип определяющий производимую операцию.

enum Action {
D_WRITE,	записъ на ленту
D_READ,		чтение с ленты
D_COMPARE,	контролъ записи сравнением
D_VERIFY	верификация информации (контролъ CRC)
};

	Структура, включающая параметры ленты.

typedef struct
{
DWORD	format;
	формат ленты (возможные значения этого параметра описана в файле
	ARVIDAPI.H)
DWORD	length;
	длина ленты в минутах
BOOL	read_only;
	TRUE - лента доступна толъко по чтению; FALSE - полный доступ к ленте
} TAPE_INFO;

	Структура, описывающая элемент оглавления.

typedef struct 
{
BOOL		fdir;
	TRUE - директория, FALSE - файл
FILETIME	time;
	время последней модификации файла (директории)
DWORD		size;
	размер файла.
	ДЛЯ ДИРЕКТОРИИ РАЗМЕР НЕ ОПРЕДЕЛЕН
DWORD		startsector;
	первый сектор на ленте, в котором записан файл.
	ДЛЯ ДИРЕКТОРИИ НАЧАЛЪНЫЙ СЕКТОР НЕ ОПРЕДЕЛЕН
char		name[MAX_PATH];
	имя файла (директории)
char		description[MAX_DESCRIPTION];
	описание файла (директории). MAX_DESCRIPTION=4096
} TAPE_FILE_DATA;

	Структура, описывающая элемент, передаваемый при чтении или записи.

enum ErrReason
{
ERR_FATAL,		фаталъная ошибка
ERR_NOT_OPEN,		ошибка при открытии файла на диске
ERR_FILE_READ_ERROR,	ошибка при чтении файла на диске
ERR_FILE_WRITE_ERROR,	ошибка при записи файла на диск
ERR_DISK_FULL,		диск переполнен
ERR_ARVID_READ_ERROR,	ошибка при чтении файла на ленте
ERR_NOT_CLOSE,		ошибка при закрытии файла на диске
ERR_COMPARE_ERROR	ошибка при сравнении файлов на диске и на ленте
};

typedef struct
{
ErrReason    	error_code;
	причина, по которой файл не был прочитан/записан
char		disk_name[MAX_PATH];
	полное имя файла на диске
char		tape_name[MAX_PATH];
	полное имя файла на ленте
char		description[MAX_DESCRIPTION];
	описание файла
}ARVID_FILE_DATA;

class StatError
{
DWORD	err[3];
	число одиночных, двойных и тройных ошибок
DWORD	nsect;
	число считанных секторов
};

class Statistics
{
char			CurrentFile[MAX_PATH];
	обрабатываемый в данный момент файл.
StatError		CurFileErrors,
	статистика об ошибках для данного файла.
StatError		TotalErrors;
	статистика об ошибках для операции в целом.
DWORD			CurFileSize,
	размер обрабатываемого файла.
DWORD			CurFileObr,
	число байт, обработанных на данный момент для обрабатываемого файла.
DWORD			CurFileDensity,
	плотностъ записи для обрабатываемого файла.
DWORD			CurFileRetries,
	число откатов при чтении обрабатываемого файла.
unsigned __int64	TotalSize,
	число байт, обрабатываемых в данной операции.
unsigned __int64	TotalObr,
	число байт, обработанных на данный момент для операции в целом.

unsigned __int64	DopObr,

DWORD			TotalData,

DWORD			StartTime,

DWORD			UpdateTime,

DWORD			TotalDensity,
	плотностъ записи для ленты в целом.
DWORD			TotalRetries,
	число откатов для операции в целом.
DWORD			TotalFiles,
	число файлов, обрабатываемых в операции.
DWORD			GoodFiles,
	число успешно обработанных файлов.
DWORD			BadFiles,
	число файлов, при обработке котрых произошла ошибка.
DWORD			regime;
	режим.
};

******** ВОЗМОЖНЫЙ АЛГОРИТМ ЧТЕНИЯ ОГЛАВЛЕНИЯ ЛЕНТЫ *************************
		(приводится фрагмент программы)

char		dname[MAX_PATH];
TAPEHANDLE	th;

void	AddSlash(char *name)
{
if(name[0]==0) lstrcpy(name,"\\");
else if(name[lstrlen(name)-1]!='\\') lstrcat(name,"\\");
}

void	DelSlash(char *name)
{
int	i,
	len=lstrlen(name);
for(i=len-1;i>=0;i--)
	if(name[i]=='\\')
		{
		name[i]=0;
		break;
		}
}

void	BeginRead()
{
if(AvdOpenTape("F:\\ARVID\\AVT\\TEST.AVT",&th))
	return;
lstrcpy(dname,"\\");
RecursiveRead();
AvdCloseTape(th);
}

void	RecursiveRead()
{
DIRHANDLE	dh;
TAPE_FILE_DATA	tfd;
if(AvdOpenDirectory(th,dname,&dh))
	return;
while(!NULL)
	{
	if(AvdGetNextFile(dh,&tfd)) break;
	if(tfd.fdir)
		{
		/* обработка директории
			...
		*/
		// рекурсивный вызов
		AddSlash(dname);
		lstrcat(dname,tfd.name);
		ResursiveRead();
		}
	/* обработка файла
		...
	*/
	}
DelSlash(dname);
AvdCloseDirectory(dh);
}
