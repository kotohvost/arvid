/*
 * Открыт Владимиром Зарожевским, по исходнику arvid10.exe Ver. 3.46r4
 * и файлу arvidapi.h пробегавшим по эхе SU.HARDW.SUPPORT.ARVID
 *	Файл-описание интерфейса АрВид V0.01beta (Arvid API)
 *  Содержит:
 *	- символическое описание кодов завершения
 *	- описание используемых структур данных
 *
 * составлен для Arvid 1010.
 */

/* Про железо */

#define	RamSize		4096	/* размер ОЗУ карты в байтах */

/* Порты используемые устройством
 * ArvidPort	= 220h | 320h

 * для записи
 * Reg_Addr0	= ArvidPort
 * Reg_Addr1	= ArvidPotr + 2
 * Reg_CMD	= ArvidPort + 4
 * Reg_DATA	= ArvidPort + 6
 */
#define HARDREADY	0x8000	/* готовность железа */

/*
 * Ниже описывается _как_ записаны данные на ленте для АРВИДа 1010
 *
 * перед записью на ленту формируется блок из 2064 байт в следующем порядке:
 * ----------------------------------------------
 * | 		первые 256 байт			|
 * ----------------------------------------------
 * | 		вторые 256 байт	- 8		|
 * ----------------------------------------------
 * | 		третьи 256 байт			|
 * ----------------------------------------------
 * | 		четвертые 256 байт - 8		|
 * ----------------------------------------------
 * | 		пятые 256 байт			|
 * ----------------------------------------------
 * | 		шестые 256 байт	- 8		|
 * ----------------------------------------------
 * | 		седьмые 256 байт		|
 * ----------------------------------------------
 * | 		восьмые 256 байт - 8		|
 * ----------------------------------------------
 * | 	8 байт - из второго блока		|
 * ----------------------------------------------
 * | 	8 байт - из четвертого блока		|
 * ----------------------------------------------
 * | 	8 байт - видимо контрольная сумма	|
 * ----------------------------------------------
 * | 	8 байт - из шестого блока		|
 * ----------------------------------------------
 * | 	8 байт - из восмого блока		|
 * ----------------------------------------------
 * | 	8 байт - видимо контрольная сумма	|
 * ----------------------------------------------
 *
 * дальше идет структура TPB на ленте 24 байта
 */
typedef struct {
	u_char	TapeFormat;	/* формат ленты */
/* форматы лент Арвид */
#define FORMAT_K4	0x1	/* формат (reserved) */
#define FORMAT_K7	0x2	/* формат 1010 100K/s (old) */
#define FORMAT_K7CRC	0x4	/* формат 1010 100K/s c улучшенным CRC32 */
#define FORMAT_RS	0x8	/* формат 1020,103X 200K/s код Рида-Соломона */
#define FORMAT_RSC	0x10	/* формат 1020,103X >200K/s код Рида-Соломона
				   с возможностью сжатия */
	u_char	TapeFormatNum;	/* номер формата записи */
#define	FORMATNUM_1010	0x33	/* */

	u_char	TapeName[8];	/* имя ленты */
	u_short	TapeID;		/* уникальный индентификатор ленты */
	u_short	TapeTime;	/* длина ленты в минутах */

	u_short	Tapetime;	/* текущее время в секундах */
	u_char	TapeSectr[3];	/* номер сектора (512b) */
	u_char	TapeFlag;	/* флаг блока */
# define TDRDATA	0	/* данные в блоке относятся к файлам */
# define TDRBLOCK	0x80	/* данные в блоке относятся к TDR */
	u_short	TapeCRC32L;	/* контрольная сумма TPB */
	u_short	TapeCRC32H;	/* контрольная сумма TPB */
} TPBInfo;

/*
 * потом идет информация о том кому принадлежат данные
 * и где они находятся, это тоже 24 байта
 */

/* пока неизвестен формат */
typedef struct {
	char	reserv[24];
} TDBInfo;

/* общая структура на один кадр */

#define SizeData	2064	/* данные в байтах */

typedef struct {
	char	data[SizeData];	/* данные */
	TPBInfo	TPB;		/* структура ленты */
	TDBInfo	TDB;		/* инфо о данных */
} avt_kadr;

#define SizeKadr	2112

/*
 * Итого мы получаем ровно 2112 байт в одном кадре. После этого
 * кадр кодируется XOR преобразованием из 24 -> 66. Получается
 * чуть меньше размера ОЗУ карты. Дело в том что нерекомендуется
 * использовать первую строку данных (для 1010 = 34 байта)
 * Это связанно с настройкой аппаратуры на ленту. 
 */

/*
 * это внутренние структуры
 */

/* fifo */
typedef struct {
	long		count;	/* количество кадров */
	avt_kadr	buf[8]; /* кадры */
} avt_fifo;

/*
 * общая структура
 */
struct avtvar {
	u_char	av_mode;		/* 0 - read, write, seek ... */
	u_char	av_stat;		/* 1 - состояние магнитофона */
	u_short	speed;			/* 2 - скорость */
	u_char	row;			/* 4 - */
	u_char	raw [RamSize];		/* 5 - прочитанный кадр */
	u_char	data [SizeKadr];	/* 4101+0 8 - дата кадра */
};

/*

// коды завершения, возвращаемые функциями API
#define OK_VCR  0               // успех
enum{
	E_OK=0,                 // успех
	E_DRIVER_NOT_INSTALLED=1,      // драйвер не установлен
	E_DEVICE_INVALID_OR_ALREADY_EXIST=2,// неверный AVHANDLE
	E_SYSTEM_ERROR=3,       // произошла системная ошибка ( Windows: код в GetLastError() )
	E_NOT_TPB=4,            // не определен TPB
	E_TPB_EXIST=5,          // TPB уже определен
	E_NO_FUNCTION=6,        // функция или команда не поддерживается (неверный номер)
	E_UNKNOWN_FORMAT=7,     // считан неизвестный формат ленты
	E_NOT_FOUND_TAPE_DIR=8, // оглавление ленты не найдено
	E_NOT_AVAIL_FORMAT=9,   // неподдерживаемый формат ленты для записи
	E_NOT_POSITION=10,      // сектор не найден (тайм-аут истек)
	E_NOT_IDENTIC_TPB=11,   // несовпадение TPB (наткнулись не на ту ленту)
	E__ABORT=12,            // команда прервана пользователем
	E_OLD_DIR=13,           // оглавление устарело, найден сектор "нашей" ленты
				// после сектора, с которого задано начало записи
				// в режиме контроля оглавления
	E_NOT_DIR=14,           // не найдено оглавление ленты при записи
				// в режиме контроля оглавления
	E_ABORT_DISABLE=15,     // аборт в данный момент запрещен
	E_ABORT_RECORD=16,      // аборт,  когда ВМ был в записи
	E_TRANSL_RECORD=17,     // ошибка контроля "кольца" в режиме REC
	E_NO_IRC_RCV=18,        // не было приема ИК клавиши (для команды ввода ИК)
	// ддалее коды возврата AvdCheckStop
	OFF_VCR=19,             // ВМ вероятно выключен
	TUNER_VCR=20,           // ВМ либо формирует свое изображение на экране TV, либо
				// принимает сигнал с эфира
	PICTURE_VCR=21,         // аналогично, но видео транслируется частично
	REC_OK_VCR=PICTURE_VCR,   // зарезервировано

	E_TAPE_FULL=22,         // раннее предупреждение о конце ленты
				// при записи (выдается за 1 мин. до конца)
				// выдается при записи
	E_FIND_DIR=23,          // при поиске сектора со спец. аттрибутом
				// обнаружено оглавление ленты
	E_INVALID_PARAM=24,     // неверные параметры в команде
        E_INVALID_SEQUENCE=25,  // неверная последовательность команд (чтения или записи)
	E_REACH_END_TAPE=26,    // достигнута метка конца ленты (при чтении)
	E_ERROR_OR_SKIP_DATA=27,// не все данные команды чтения считаны
	E_BAD_VCR_TABLE=28,     // загружается неверная таблица ВМ
	E_INCOMPATIBLE_LOW_LEVEL_DRIVER=29, // несовместимый драйвер драйвер нижнего уровня ( .VxD or .SYS )
	E_UNKNOWN_FORMAT_PT=30, // неизвестный формат таблицы позиционирования
	E_BAD_PT=31,            // неверная таблица позиционирования (ТП)
	E_MISMATCH_FORMAT_PT=32,// несоответствие форматов ленты и ТП
	E_INTERNAL_DRIVE_ERROR=33, // internal drive error
        E_SECTOR_NOT_ACCESSIBLE=34,// сектор для поиска недоступен( истек счетчик откатов )
	E_UNKNOWN_ERROR         // неизвестная ошибка, если >= E_UNKNOWN_ERROR
};

// константы для функции узнать AvdIsTape
#define NOT_TAPE        0       // нет ленты
#define TPB_TAPE        1       // параметры ленты загружены


// режимы перемещения ленты ВМ ( состояния ВМ )
enum {
   VCR_STOP=0           ,          // состояние STOP
   VCR_PLAY             ,          // состояние PLAY
   VCR_PLAY_FF          ,          // ускоренное воспроизведение вперед
   VCR_PLAY_REW         ,          // ускоренное воспроизведение назад
   VCR_nPLAY_FF         ,          // зарезервировано, ускоренное воспроизведение вперед (вторая скорость)
   VCR_nPLAY_REW        ,          // зарезервировано, ускоренное воспроизведение назад  (вторая скорость)
   VCR_FF               ,          // ускоренная перемотка вперед
   VCR_REW              ,          // ускоренная перемотка назад
   VCR_REC              ,          // режим записи на ленту
   VCR_MAX= VCR_REC                // макс значение режима
};



#define VER_PROTO_API   0x100   //

// далее следуют определение структур данных, используемых API

//	1. Блок параметров драйвера Арвид
// определяет основные характеристики, постоянные для данной версии драйвера
*/

/* биты аттрибутов (в поле attributs) */

#define USED_AUTO_PHASE 0x1	/* драйвер поддерживает автофазирование */
#define USED_COMPRESS   0x2	/* драйвер поддерживает ленты со сжатием */
#define USED_XOR        0x4	/* драйвер поддерживает избыточные кадры XOR */

enum avttype {
	UNKNOWN = 0,	/* unknown type, driver disabled */
	Av1010,		/* 1010 - 100 Kb/s (180min = 1Gb) */
	Av1020,		/* 1020 - 200 Kb/s (180min = 2Gb) */
	Av1030,		/* aka 1031 & 103x - 200Kb/s + compression */
};

struct avt_info {		/* Driver Parameters Block */
/* Неменяемые характеристики в процессе работы */
/*	u_short	size; */	/* размер структуры для драйвера */
	enum avttype controller;	/* тип контроллера */
	u_short	port;		/* номер базового порта */
	u_short	irq;		/* прерывание */
	u_char	ver_major,
		ver_minor;	/* версия драйвера */
	u_char	formats;	/* побитовый список поддерж. форматов ленты */
	u_short	maxrate;	/* макс. скорость передачи [100-200] Кбайт/cек */
	u_char	maxphase;	/* макс. величина параметра phase */

/*	2. Блок режимов драйвера Арвид
 * определяет характеристики, которые могут изменяться для указанного Device
 */
/*     struct CDPB {           // Current Device Parameters Block */
	u_short	flags;		/* статус драйвера */
	u_char	commands;	/* текущая команда */
	u_char	time_out;	/* время тайм-аута, секунд, т.е. время,
				   по истечении которого операция прекращается,
				   если на ленте не найдено никакой информации
				   (по умолчанию 13 секунд) */
	u_short	rate;		/* скорость передачи [100-200] Кбайт/cек */
	u_char	phase;		/* текущая фаза приема */
#define DEFAULT_PHASE	2
#define PHASEMASK	0x0C	/* 0000000000001100B */
#define SETPHASECMD(phase)	((phase >> 2) & PHASEMASK)
	u_char	check_rec;	/* флаг контроля кольца в реж. Record */
/*	u_short	lp; */		/* флаг работы в режиме LongPlay
				   ( д.б. 0 ) reserved
				   и ваще должен быть в структуре видика */
	u_char	auto_phase;	/* флаг: текущая работа в режиме
				   автоподстройки фазы */
/*	U8      compress_enable; // флаг: при записи данных в формате FORMAT_RSC
				 // сжатие разрешено
	U8      xor_enable;  //  разрешено формировать XOR блоки при записи
	U8      xor_block_size;   // кол-во кадров в XOR блоке при записи
	U8      xor_block_number; // кол-во блоков в XOR области при записи
	U32     reserv;     // reserv
*/
};
typedef	struct	avt_info avt_info_t;

#if 0
	3. Блок параметров ленты:

// определяет характеристики ленты, с которой сейчас работает Арвид

     struct TPBOLD {    // Tape Parameters Block для форматов менее FORMAT_RSC
	U16     format;        // формат ленты
	U16     length;        // длина ленты в минутах
	char    name[8];       // имя ленты
	U16     ident;         // идентификатор ленты (уникальный номер)
	U16		resrv;
	U32     reserv;        // reserv
     };
     struct TPBNEW {       // Tape Parameters Block для формата FORMAT_RSC
	U16     format;		// формат ленты
	U16     length;		// длина ленты в минутах
	U32     tapeID;		// имя ленты ( идентификатор-уникальный номер )
	U8      reserv[sizeof(TPBOLD)-8];     // reserv
     };

     struct TPB {	// общая структура TPB
	U16	format;
	U16	length;
	union {
	  struct {
	    char	name[8];
	    U16		ident;
		U16		resrv;
	    U32		reserv;
	  };
	  U32	tapeID;
	};
     };
#endif

#if 0
//     4. Блок текущих параметров устройства при работе с лентой
// может использоваться при отображении текущего состояния
     struct CurTPB {       // Current Tape Parameters Block
	U16     cur_time;  // текущее время от начала ленты, сек
	U16     targ_time; // время цели, сек
	U32     cur_sect;  // текущий сектор
	U32     targ_sect; // сектор цели
	U16     state_vcr; // текущее состояние ВМ (константы см выше)
	// далее идет часть, используемая AVSETUP
	U32     pure_st;   // кол-во чистых кадров ( без ошибок )
			   // от начала операции чтения
        U32     reserv[4];     // reserv
     };

//      5. Блок аппаратных установок устройства
     struct DHB {       // Device Hardware parameters Block
	U16     port;   // базовый порт
	U16     dma;    // номер канала DMA
	U16     irq;    // номер канала IRQ
	U16     busy;   // 0, если может быть открыт AvdOpen
	U8      reserv[8];
     };

// описание типа: сектор данных
#define SIZE_SECTOR_BYTES       512    // размер сектора для ArvidApi
#define SIZE_SECTOR_WORDS       (SIZE_SECTOR_BYTES/2)
#define SIZE_SECTOR_DWORDS      (SIZE_SECTOR_BYTES/4)
typedef char SectData[SIZE_SECTOR_BYTES];
typedef SectData _FAR_ *SectDataBlock; // указатель на сектора

#endif

/*-------------------------------------------------
	прототипы функций интерфейса
 --------------------------------------------------
// далее следуют прототипы функций API

// первый параметр большинства функций - AVHANDLE - значение,
// получаемое при открытии (функция AvdOpen)

// каждая функция API возвращает код возврата. Нет ошибок - E_OK,
// иначе - код ошибки

// соглашение о передаче параметров
#ifndef __OS2__
    #define AVDCONV  _FAR_ _stdcall
#else
 #ifdef __BORLANDC__
    #define AVDCONV  pascal
 #else
    #define AVDCONV  _Pascal
 #endif
#endif
    #ifndef  INVALID_HANDLE_VALUE
     #define AVHANDLE        unsigned
     #define INVALID_HANDLE_VALUE        ((AVHANDLE)(-1))
    #else
     #define AVHANDLE        unsigned
    #endif
     #define AVDRET          int

     #define AVDPROC         extern "C" __DLLFUNC  AVDRET       AVDCONV


//         1. Установление/разрыв взаимодействия с Arvid

     AVDPROC          AvdInstall();
	// Установить связь с драйвером (загрузить драйвер)
	// должна быть первой вызываемой функцией API
     AVDPROC          AvdOpen( unsigned numDevice,AVHANDLE _FAR_ *h );
	// Открыть handle драйвера для данного Device (контроллера АрВид)
	// Это - функция установления связи с Arvid. Полученный AVHANDLE
	// должен использоваться в последующих обращениях к API
	// Если устройство уже занято другим приложением - ошибка
     AVDPROC          AvdClose( AVHANDLE h );
        // Закрыть handle драйвера - освобождает устройство для других
	// приложений
     AVDPROC          AvdDeInstall();
        // Разорвать связь с драйвером (выгрузить драйвер).
        // Должна быть последней вызываемой функцией API
     AVDPROC          AvdGetNumberDevices( U32 _FAR_ *pNumDevs );
	// Узнать кол-во устройств, доступных драйверу

//        2. Управление параметрами драйвера.

     AVDPROC AvdGetDPB( AVHANDLE h,DPB _FAR_ *dpb );
	// получить параметры драйвера
     AVDPROC          AvdGetDHB(AVHANDLE h, DHB _FAR_ *dhb );
	// получить аппаратные установки для Device

     // AVDPROC AvdSetDHB( AVHANDLE h,const DHB _FAR_ *dhb );
	// задать аппаратные установки драйвера

     AVDPROC AvdGetCDPB( AVHANDLE h,CDPB _FAR_ *drb );
	// получить текущие режимы драйвера
     AVDPROC AvdSetCDPB( AVHANDLE h,const CDPB _FAR_ *drb );
	// задать текущие режимы драйвера
     AVDPROC AvdSetPhase( AVHANDLE h,int phase );
	// установить фазу приема ( можно во время чтения )
     AVDPROC AvdSetAutoPhase( AVHANDLE h,int phase );
	// установить фазу приема  с автоподстройкой фазы
	// ( можно во время чтения )

//       3. Работа с лентой.

// программа, работающая с Arvid может может работать не более чем с одной
// лентой одновременно.

//	3a. Справочные функции

     AVDPROC AvdIsTape( AVHANDLE h, U32 _FAR_ *isTape );
	// узнать установлены ли параметры ленты
     AVDPROC AvdGetTape( AVHANDLE h,TPB _FAR_ *tpb );
	// получить параметры ленты
     AVDPROC AvdGetCurTPB( AVHANDLE h,CurTPB _FAR_ *curpb );
	// получить текущие параметры драйвера при работе с лентой

//	3b. Сброс ленты.
     AVDPROC AvdResetTape( AVHANDLE h );
	// сбросить установки ленты

//	3c. Установка ленты
// Перед установкой ленты нужно сбросить предыдущую!
     AVDPROC AvdSetTape( AVHANDLE h,const TPB _FAR_ *tpb );
	// установить параметры новой ленты (инициализация),
	// или принудительно задать ленту, параметры которой известны

     #define IDENT_WITH_REW     1       // с отмоткой
     #define IDENT_QUICK        0       // без
     AVDPROC AvdIdentify( AVHANDLE h,int Control );
	// идентифицировать ленту (т.е. определить ее TPB)

//	3d. Работа с таблицей позиционирования (position table,PT)

//  для каждой обслуживаемой ленты Арвид ведет таблицу позиционирования -
//  таблицу соответствия номера сектора и времени от начала ленты. Она
//  позволяет быстро ориентироваться на ленте, несмотря на возможную
//  неравномерность записанных данных.
//  Приложение, работающее с API должно сохранять PT в промежутках между
//  cеанcами работы с лентой. Т.е. после операции записи (когда PT изменяется)
//  необходимо считать PT и сохранить ее. В дальнейшем, после идентификации
//  ленты необходимо загрузить ранее сохраненную PT.
//  Длина PT постоянна и зависит только от формата ленты.

     AVDPROC AvdGetPTLength( AVHANDLE h , U32 _FAR_ *ptLength );
	// получить длину таблицы позиционирования в байтах
	// должна выдаваться когда лента уже загружена (известен ее формат)
     AVDPROC AvdGetPT( AVHANDLE h,void _FAR_ * addr );
	// получить таблицу позиционирования ленты
	// addr - адрес буфера, длина которого определяется в AvdGetPTLength
     AVDPROC AvdSetPT( AVHANDLE h,const void _FAR_ * addr );
	// загрузить таблицу позиционирования ленты
     AVDPROC AvdGetSectorTime( AVHANDLE h , U32 sector ,U32 _FAR_ *sectorTime, void _FAR_ * pPosTbl );
	// справочная функция определения времени по номеру сектора на
	// основании PT
	// pPosTbl указатель на PT (если 0, то из загруженной в драйвер)


//	4.Работа с параметрами ВМ.
// Для обеспечения нормальной работы с ВМ приложение должно задать таблицу
// управления параметрами ВМ. Она может загружаться либо из файла,
// либо из памяти (например при сетапе).

     AVDPROC AvdSetVCR( AVHANDLE h,const char _FAR_ *fname );
	// загрузить таблицу управления ВМ из файла
     AVDPROC AvdSetVCRAddr( AVHANDLE h,const void _FAR_ *vcr );
	// загрузить таблицу управления ВМ


//      Программирование процесса чтения/записи

// При программировании процессов чтения/записи нужно иметь ввиду следующее:
// функции чтения/записи не возвращают управление до тех пор, пока операция
// не выполнится полностью. Поэтому для операций с диском/абортирования
// рекомендуется использовать доп. потоки (threads).

//	5.Запись информации на ленту.

//при записи информации необходимо выдерживать межзаписный промежуток в
// нумерации секторов
//(чтобы избежать накладок) Узнать этот безопасный промежуток можно функцией:
     AVDPROC AvdGetInterRecord( AVHANDLE h , U32 _FAR_ *interRec );
	// узнать размер межзаписного промежутка ( в секторах для текущего формата ленты
	// и для данного типа ВМ)

     // Параметр RecMode для AvdWriteStart
     // -- тип операции записи
     #define REC_CURRENT_PLACE 0 //- с текущего места
     #define REC_DIR_CHECK     1 //- с указ.сектора aftersect с контролем оглавления
     #define REC_NO_DIR_CHECK  2 //- -------//------------------- без --------//--------
     #define REC_MAX_CODE      (REC_NO_DIR_CHECK)

     AVDPROC AvdWriteStart( AVHANDLE h,int RecMode, U32 aftersect );
	// начать запись данных
	// это - первая команда процесса записи
	// по ней Арвид переходит в режим REC либо сразу, либо (в зависимости
	// от заданного режима ) после считывания указанного в команде сектора
	// aftersect. Как правило это - последний сектор предыдущей записи
	//
     // Параметр ControlFlags для AvdWrite
     #define REC_ENABLE_COMPRESS  0          // варианты поля ControlFlags
     #define REC_DISABLE_COMPRESS 0x8000     // запрет сжатия для архивов
     AVDPROC AvdWrite( AVHANDLE h,const void _FAR_ * data, U32 begSect,
       U16 nSect , int ControlFlags );
	// запись данных (обычных)
	// begSect - номер начального сектора
	// nSect - число секторов
	// нумерация секторов в последовательных командах должна быть
	// непрерывной
     AVDPROC AvdWriteDirectory( AVHANDLE h,const void _FAR_ * data, U32 begSect,
       U16 nSect  );
	// запись оглавления ленты
	// отличается от обычной тем, что сектора помечаются спец. признаком,
	// который затем ищется процедурой поиска оглавления
     AVDPROC AvdWriteLog( AVHANDLE h,const void _FAR_ * data, U32 begSect, U16 nSect  );
	// запись данных со спец. аттрибутом
	// отличается тем, что сектора помечается аттрибутом, позволяющим
	// выделить его затем из прочих секторов
	// В настоящее время этим методом помечаются сектора с информацией о
	// записываемых файлах, затем такие сектора находятся рековером
	// В дальнейшем возможно иное использование
//     AVDPROC AvdWritePT( AVHANDLE h, const void _FAR_ * data, U32 begSect, U16 nSect );
	// запись таблицы позиционирования
     AVDPROC AvdWritePause( AVHANDLE h , unsigned  pause_second );
	// запись паузы в процессе записи (например, в начале ленты или перед
	// оглавлением)
	// если (pause_second==0) - стандартная пауза перед оглавлением
     AVDPROC AvdWriteEnd( AVHANDLE h );
	// конец записи - последняя команда процесса записи

//         6. Чтение информации с ленты.

     // описание структуры, всегда возвращаемой
     // при чтении секторов данных
     struct     RD_RESULT
     {
	U32             nReadSect;   // кол-во реально считанных секторов
	U32             errors[3];   // статистика исправленных ошибок
				     // однократные, двухкратные и трехкратные
	U32             begSect;     // номер первого прочитанного сектора
				     //	(имеет смысл в процедурах поиска)
     };
     // значения поля ControlFlags
     #define DEFAULT_FLAGS     0
     #define USED_XOR_RESTORE  0x8000

     AVDPROC AvdRead( AVHANDLE h,void _FAR_ * data, U32 begSect, U16 nSect ,
      int ControlFlags, RD_RESULT _FAR_ * p );
	// чтение данных, в  RD_RESULT результат чтения
	// основная функция процесса чтения
     AVDPROC AvdReadEnd( AVHANDLE h,int Control );
	// окончание чтения данных - последняя команда процесса чтения

     AVDPROC AvdReadLog( AVHANDLE h,void _FAR_ * data, U16 nSect , RD_RESULT _FAR_ * p  );
	// поиск (последовательным просмотром ) сектора со спец. аттрибутом
	// и чтение nSect секторов начиная с него
     AVDPROC AvdReadDirectory( AVHANDLE h,void _FAR_ * data, U16 nSect , RD_RESULT _FAR_ * p  );
	// чтение-поиск секторов оглавления, начиная с первого встретившегося.
	// Используется метод бинарного поиска ("Лев в пустыне" ;-)
     AVDPROC AvdReadDirectoryQuick( AVHANDLE h,void _FAR_ * data, U16 nSect , RD_RESULT _FAR_ * p  );
	// чтение-поиск секторов оглавления, начиная с первого встретившегося,
        // без использования льва в пустыне (последовательным просмотром )

//         7. Специальные процедуры.

     AVDPROC AvdAbort( AVHANDLE h );
	// прекратить выполнение любых операций драйвера
     AVDPROC AvdIrcKeyTrn( AVHANDLE h,int Control );
	// передать ИК клавишу с номером Control
     AVDPROC AvdHardwareTest( AVHANDLE h  );
	// выполнить простейшую проверку работоспособности аппаратуры
	// с текущими установками в DHB
     AVDPROC AvdCheckStop( AVHANDLE h );
	// узнать параметры кольца трансляции ВМ
     AVDPROC AvdPowerOn( AVHANDLE h,int Control );
	// условное/безусловное включение ВМ
     AVDPROC AvdPowerOff( AVHANDLE h,int Control );
	// условное/безусловное выключение ВМ
     AVDPROC AvdEject( AVHANDLE h );
	// выброс кассеты из ВМ

//       7a. В том числе процедуры перемотки ленты:
     AVDPROC AvdRewind ( AVHANDLE h );
	// выдача команды перемотки назад
     AVDPROC AvdForward( AVHANDLE h );
	// выдача команды перемотки вперед

     // следующие команды используются в avsetup
     AVDPROC AvdMoveTape( AVHANDLE h,
			unsigned  mode,        // режим перемещения ленты ВМ (VCR_FF,VCR_PLAY_FF ...)
			unsigned  time,        // время перемещения ( кадров= 1/50 сек )
			unsigned  finit_mode  // режим ВМ по окончании перемещения
      );
	// перемещать ленту в режиме mode в течении времени time (кадров= 1/50 сек)
	// по окончанию перейти в PLAY или STOP (finit_mode).
     AVDPROC AvdPosition( AVHANDLE h,
			unsigned cur,         // текущая позиция на ленте в секундах
			unsigned target,     // целевая позиция на ленте в секундах
			unsigned finit_mode   // режим ВМ по окончанию перемещения
     );
	// перемещать ленту с позиции cur (сек) на позицию target
	// по окончанию перейти в PLAY или STOP
        // драйвер сам выбирает режим движения
     AVDPROC AvdSetVirtualVcrState( AVHANDLE h, int Control );
	// перевести драйвер в состояние Control ( VCR_... )
	// без реального переключения ВМ
     AVDPROC AvdSetVcrState( AVHANDLE h, int Control );
	// перевести ВМ в состояние Control ( VCR_... )

#endif // End of file ARVIDAPI.H
*/

/* для прямого чтения из карты */

typedef struct {
	u_char	data[RamSize];
} avt_raw;


/* ioctl функции */
#define	VGET_INFO	_IOR('A',  1, struct avt_info)	/* читаем конфиг драйвера */
#define	VGET_RAW	_IOR('A',  8, avt_raw)		/* читаем raw данные */
#define	VGET_KADR	_IOR('A',  9, avt_kadr)		/* читаем kadr */
#define	VAVT_TEST	_IOR('A', 10, avt_fifo)		/* читаем данные */
